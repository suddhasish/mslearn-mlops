name: CD - MLOps Deployment (Managed Endpoint + AKS)

# This workflow uses Terraform-deployed DEV infrastructure
# - Staging endpoint: Azure ML Managed Online Endpoint (ml-endpoint-staging)
# - Production deployment: AKS cluster (mlopsnew-dev-aks)
# 
# Infrastructure: mlopsnew-dev-* resources (deployed via Terraform)
# See INFRASTRUCTURE_INTEGRATION.md for details

on:
  workflow_dispatch:
    inputs:
      model_name:
        description: 'Model name to deploy'
        required: true
        default: 'diabetes_classification'
      model_version:
        description: 'Model version (e.g., 1, 2, latest)'
        required: true
        default: 'latest'
      setup_monitoring:
        description: 'Setup Prometheus + Grafana monitoring stack? (first-time only)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      setup_ingress:
        description: 'Setup NGINX Ingress for dashboard access? (first-time only)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
  repository_dispatch:
    types: [aml_model_registered]

# Prevent concurrent deployments to same environment
concurrency:
  group: cd-deployment-${{ github.ref }}
  cancel-in-progress: false

env:
  PYTHON_VERSION: '3.11'
  
  # Infrastructure (Terraform-deployed DEV environment)
  # Note: Both staging and production use DEV infrastructure
  AZURE_SUBSCRIPTION_ID: 'b2b8a5e6-9a34-494b-ba62-fe9be95bd398'
  RESOURCE_GROUP: 'mlopsnew-dev-rg'
  ML_WORKSPACE: 'mlopsnew-dev-mlw'
  
  # Endpoint configuration
  # Staging endpoint: For initial testing and validation
  AZURE_ML_STAGING_ENDPOINT_NAME: ml-endpoint-staging
  STAGING_DEPLOYMENT_NAME: staging-deployment
  
  # Production deployment: AKS cluster (will be resolved dynamically)
  AKS_NAMESPACE: production
  
  # Deployment configuration
  MAX_WAIT_ITERATIONS: 30
  WAIT_INTERVAL_SECONDS: 10

jobs:
  # Centralized input resolution
  resolve-inputs:
    name: Resolve Deployment Inputs
    runs-on: ubuntu-latest
    outputs:
      model_name: ${{ steps.resolve.outputs.model_name }}
      model_version: ${{ steps.resolve.outputs.model_version }}
      aml_workspace: ${{ steps.resolve.outputs.aml_workspace }}
      resource_group: ${{ steps.resolve.outputs.resource_group }}
      subscription_id: ${{ steps.resolve.outputs.subscription_id }}
      deployment_id: ${{ steps.resolve.outputs.deployment_id }}
      aks_cluster_name: ${{ steps.get_infrastructure.outputs.aks_cluster_name }}
      acr_name: ${{ steps.get_infrastructure.outputs.acr_name }}
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Generate deployment ID
        id: deployment_id
        run: echo "id=deploy-$(date +%Y%m%d-%H%M%S)-${{ github.run_id }}" >> $GITHUB_OUTPUT

      - name: Get infrastructure details
        id: get_infrastructure
        run: |
          # Query AKS cluster name from resource group
          AKS_NAME=$(az aks list --resource-group "${{ env.RESOURCE_GROUP }}" \
            --subscription "${{ env.AZURE_SUBSCRIPTION_ID }}" \
            --query "[0].name" -o tsv)
          
          # Query ACR name from resource group
          ACR_NAME=$(az acr list --resource-group "${{ env.RESOURCE_GROUP }}" \
            --subscription "${{ env.AZURE_SUBSCRIPTION_ID }}" \
            --query "[0].name" -o tsv)
          
          echo "aks_cluster_name=$AKS_NAME" >> $GITHUB_OUTPUT
          echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
          
          echo "Found AKS cluster: $AKS_NAME"
          echo "Found ACR: $ACR_NAME"

      - name: Resolve all inputs
        id: resolve
        run: |
          # Resolve model name/version and infrastructure details
          MODEL_NAME=${{ github.event.inputs.model_name || github.event.client_payload.model_name || 'diabetes_classification' }}
          MODEL_VERSION_RAW=${{ github.event.inputs.model_version || github.event.client_payload.model_version || 'latest' }}

          echo "Resolving model: $MODEL_NAME (requested: $MODEL_VERSION_RAW)"

          if [ "${MODEL_VERSION_RAW}" = "latest" ]; then
            # Query Azure ML for all versions and get the latest one
            MODEL_VERSION=$(az ml model list \
              --name "${MODEL_NAME}" \
              --workspace-name "${{ env.ML_WORKSPACE }}" \
              --resource-group "${{ env.RESOURCE_GROUP }}" \
              --subscription "${{ env.AZURE_SUBSCRIPTION_ID }}" \
              --query "[0].version" -o tsv)

            if [ -z "${MODEL_VERSION}" ] || [ "${MODEL_VERSION}" = "null" ]; then
              echo "::error::No registered versions found for model '${MODEL_NAME}'"
              exit 1
            fi
            
            echo "‚úì Resolved 'latest' to version: ${MODEL_VERSION}"
          else
            MODEL_VERSION=${MODEL_VERSION_RAW}
          fi

          echo "model_name=${MODEL_NAME}" >> $GITHUB_OUTPUT
          echo "model_version=${MODEL_VERSION}" >> $GITHUB_OUTPUT
          echo "aml_workspace=${{ env.ML_WORKSPACE }}" >> $GITHUB_OUTPUT
          echo "resource_group=${{ env.RESOURCE_GROUP }}" >> $GITHUB_OUTPUT
          echo "subscription_id=${{ env.AZURE_SUBSCRIPTION_ID }}" >> $GITHUB_OUTPUT
          echo "deployment_id=${{ steps.deployment_id.outputs.id }}" >> $GITHUB_OUTPUT

      - name: Display infrastructure configuration
        run: |
          echo "### üèóÔ∏è Infrastructure Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Using DEV Infrastructure** (Staging and Production endpoints in same workspace)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Resource Group | ${{ steps.resolve.outputs.resource_group }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ML Workspace | ${{ steps.resolve.outputs.aml_workspace }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Subscription | ${{ steps.resolve.outputs.subscription_id }} |" >> $GITHUB_STEP_SUMMARY
          echo "| AKS Cluster | ${{ steps.get_infrastructure.outputs.aks_cluster_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ACR | ${{ steps.get_infrastructure.outputs.acr_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Endpoints:**" >> $GITHUB_STEP_SUMMARY
          echo "- Staging: `${{ env.AZURE_ML_STAGING_ENDPOINT_NAME }}` (Managed Online Endpoint)" >> $GITHUB_STEP_SUMMARY
          echo "- Production: `${{ steps.get_infrastructure.outputs.aks_cluster_name }}/${{ env.AKS_NAMESPACE }}` (AKS Cluster)" >> $GITHUB_STEP_SUMMARY

      - name: Log deployment configuration
        run: |
          echo "### üöÄ Deployment Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Model Name | ${{ steps.resolve.outputs.model_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Model Version | ${{ steps.resolve.outputs.model_version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deployment ID | ${{ steps.resolve.outputs.deployment_id }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Infrastructure | DEV (simulating prod) |" >> $GITHUB_STEP_SUMMARY

  deploy-staging:
    name: Deploy to Staging Environment
    needs: resolve-inputs
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: ${{ steps.get_endpoint.outputs.ENDPOINT_URL }}
    outputs:
      endpoint_url: ${{ steps.get_endpoint.outputs.ENDPOINT_URL }}
      deployment_state: ${{ steps.deployment_status.outputs.state }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install azure-ai-ml azure-identity

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Install Azure ML CLI extension
        run: |
          az config set extension.use_dynamic_install=yes_without_prompt
          az extension add --name ml --yes --upgrade

      - name: Check if endpoint exists
        id: check_endpoint
        continue-on-error: true
        run: |
          az ml online-endpoint show \
            --name "$AZURE_ML_STAGING_ENDPOINT_NAME" \
            --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
            --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
            --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
            --query name -o tsv

      - name: Create staging endpoint if needed
        if: steps.check_endpoint.outcome == 'failure'
        run: |
          set -euo pipefail
          
          echo "Creating staging endpoint: $AZURE_ML_STAGING_ENDPOINT_NAME"
          
          az ml online-endpoint create \
            --name "$AZURE_ML_STAGING_ENDPOINT_NAME" \
            --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
            --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
            --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
            --auth-mode key
          
          echo "‚úì Endpoint created successfully"

      - name: Verify endpoint status
        if: steps.check_endpoint.outcome == 'success'
        run: |
          echo "‚úì Endpoint already exists, skipping creation"

      - name: Prepare deployment configuration
        run: |
          set -euo pipefail
          
          # Update deployment YAML with dynamic values
          sed -i "s|model: azureml:.*|model: azureml:${{ needs.resolve-inputs.outputs.model_name }}:${{ needs.resolve-inputs.outputs.model_version }}|g" deployment/staging-deployment.yml
          sed -i "s|DEPLOYMENT_ID: \".*\"|DEPLOYMENT_ID: \"${{ needs.resolve-inputs.outputs.deployment_id }}\"|g" deployment/staging-deployment.yml
          sed -i "s|MODEL_VERSION: \".*\"|MODEL_VERSION: \"${{ needs.resolve-inputs.outputs.model_version }}\"|g" deployment/staging-deployment.yml
          
          echo "Updated deployment configuration:"
          cat deployment/staging-deployment.yml

      - name: Check if deployment exists
        id: check_deployment
        continue-on-error: true
        run: |
          az ml online-deployment show \
            --endpoint-name "$AZURE_ML_STAGING_ENDPOINT_NAME" \
            --name "$STAGING_DEPLOYMENT_NAME" \
            --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
            --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
            --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
            --query name -o tsv

      - name: Create or update staging deployment
        id: deploy_staging
        run: |
          set -euo pipefail
          
          echo "Deploying model ${{ needs.resolve-inputs.outputs.model_name }}:${{ needs.resolve-inputs.outputs.model_version }}"
          
          if [ "${{ steps.check_deployment.outcome }}" = "success" ]; then
            echo "Deployment exists - updating..."
            az ml online-deployment update \
              --file deployment/staging-deployment.yml \
              --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
              --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
              --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}"
          else
            echo "Creating new deployment..."
            az ml online-deployment create \
              --file deployment/staging-deployment.yml \
              --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
              --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
              --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
              --all-traffic
          fi

      - name: Route all traffic to staging deployment
        if: steps.check_deployment.outcome == 'success'
        run: |
          echo "Routing 100% traffic to staging deployment..."
          az ml online-endpoint update \
            --name "$AZURE_ML_STAGING_ENDPOINT_NAME" \
            --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
            --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
            --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
            --traffic "$STAGING_DEPLOYMENT_NAME=100"

      - name: Wait for staging deployment to be healthy
        id: wait_staging
        run: |
          set -euo pipefail
          
          echo "‚è≥ Waiting up to $((MAX_WAIT_ITERATIONS * WAIT_INTERVAL_SECONDS / 60)) minutes for deployment..."
          
          for i in $(seq 1 $MAX_WAIT_ITERATIONS); do
            status=$(az ml online-deployment show \
              --endpoint-name "$AZURE_ML_STAGING_ENDPOINT_NAME" \
              --name "$STAGING_DEPLOYMENT_NAME" \
              --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
              --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
              --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
              --query provisioning_state -o tsv)
            
            echo "[$i/$MAX_WAIT_ITERATIONS] Deployment state: $status"
            
            if [ "$status" = "Succeeded" ]; then
              echo "‚úì Deployment provisioned successfully"
              exit 0
            elif [ "$status" = "Failed" ]; then
              echo "::error::Deployment provisioning failed"
              
              # Get error details
              az ml online-deployment show \
                --endpoint-name "$AZURE_ML_STAGING_ENDPOINT_NAME" \
                --name "$STAGING_DEPLOYMENT_NAME" \
                --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
                --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
                --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
                --query '{state:provisioning_state,error:provisioning_state_error}' -o json
              
              exit 1
            fi
            
            sleep $WAIT_INTERVAL_SECONDS
          done
          
          echo "::error::Timeout waiting for deployment (exceeded $((MAX_WAIT_ITERATIONS * WAIT_INTERVAL_SECONDS)) seconds)"
          exit 1

      - name: Get staging endpoint details
        id: get_endpoint
        run: |
          set -euo pipefail
          
          ENDPOINT_URL=$(az ml online-endpoint show \
            --name "$AZURE_ML_STAGING_ENDPOINT_NAME" \
            --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
            --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
            --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
            --query scoring_uri -o tsv)
          
          # Get key but mask it immediately
          ENDPOINT_KEY=$(az ml online-endpoint get-credentials \
            --name "$AZURE_ML_STAGING_ENDPOINT_NAME" \
            --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
            --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
            --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
            --query primaryKey -o tsv)
          
          # Mask the key before any output
          echo "::add-mask::$ENDPOINT_KEY"
          
          echo "ENDPOINT_URL=$ENDPOINT_URL" >> $GITHUB_OUTPUT
          echo "ENDPOINT_KEY=$ENDPOINT_KEY" >> $GITHUB_OUTPUT
          
          echo "‚úì Staging endpoint URL: $ENDPOINT_URL"

      - name: Run staging endpoint tests
        env:
          ENDPOINT_URL: ${{ steps.get_endpoint.outputs.ENDPOINT_URL }}
          ENDPOINT_KEY: ${{ steps.get_endpoint.outputs.ENDPOINT_KEY }}
        run: |
          set -euo pipefail
          
          echo "üß™ Running endpoint tests..."
          
          if [ ! -f "scripts/test_endpoint.py" ]; then
            echo "::warning::Test script not found at scripts/test_endpoint.py - skipping tests"
            exit 0
          fi
          
          python scripts/test_endpoint.py --url "$ENDPOINT_URL" --key "$ENDPOINT_KEY"
          
          echo "‚úì All staging tests passed"

      - name: Set deployment status
        id: deployment_status
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "state=success" >> $GITHUB_OUTPUT
          else
            echo "state=failure" >> $GITHUB_OUTPUT
          fi

      - name: Update deployment summary
        if: always()
        run: |
          echo "### üìä Staging Deployment Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.deployment_status.outputs.state }}" = "success" ]; then
            echo "‚úÖ **Status**: Deployment successful" >> $GITHUB_STEP_SUMMARY
            echo "üîó **Endpoint**: ${{ steps.get_endpoint.outputs.ENDPOINT_URL }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Status**: Deployment failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Model**: ${{ needs.resolve-inputs.outputs.model_name }}:${{ needs.resolve-inputs.outputs.model_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Instance**: Standard_DS2_v2 (x1)" >> $GITHUB_STEP_SUMMARY
          echo "**Infrastructure**: DEV (mlopsnew-dev-rg)" >> $GITHUB_STEP_SUMMARY

  deploy-production-aks:
    name: Deploy to Production (AKS)
    needs: [resolve-inputs, deploy-staging, await-production-approval]
    runs-on: ubuntu-latest
    environment:
      name: production
      url: http://${{ steps.get_service_ip.outputs.EXTERNAL_IP }}
    outputs:
      service_url: ${{ steps.get_service_ip.outputs.EXTERNAL_IP }}
      deployment_status: ${{ steps.rollout_status.outputs.status }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Install Azure ML CLI extension
        run: |
          az extension add --name ml --yes --upgrade

      - name: Download model from Azure ML
        run: |
          set -euo pipefail
          
          echo "Downloading model: ${{ needs.resolve-inputs.outputs.model_name }}:${{ needs.resolve-inputs.outputs.model_version }}"
          
          # Download to temporary directory
          TEMP_DIR=$(mktemp -d)
          
          az ml model download \
            --name "${{ needs.resolve-inputs.outputs.model_name }}" \
            --version "${{ needs.resolve-inputs.outputs.model_version }}" \
            --download-path "$TEMP_DIR" \
            --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
            --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
            --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}"
          
          echo "Downloaded model structure:"
          find "$TEMP_DIR" -type f
          
          # Create model directory and copy model files
          mkdir -p src/model
          
          # Find and copy the model file (usually in a nested directory)
          MODEL_FILE=$(find "$TEMP_DIR" -type f \( -name "*.pkl" -o -name "*.joblib" -o -name "*.model" \) | head -n 1)
          
          if [ -z "$MODEL_FILE" ]; then
            echo "‚ùå Error: No model file found in downloaded artifacts"
            exit 1
          fi
          
          echo "Found model file: $MODEL_FILE"
          cp "$MODEL_FILE" src/model/model.pkl
          
          echo "‚úÖ Model prepared at src/model/model.pkl"
          ls -la src/model/

      - name: Build and push Docker image to ACR
        id: build_image
        run: |
          set -euo pipefail
          
          echo "Building Docker image for AKS deployment..."
          
          # Login to ACR
          az acr login --name ${{ needs.resolve-inputs.outputs.acr_name }}
          
          # Get ACR login server
          ACR_LOGIN_SERVER=$(az acr show --name ${{ needs.resolve-inputs.outputs.acr_name }} --query loginServer -o tsv)
          
          # Build image with timestamp tag
          IMAGE_TAG="v${{ needs.resolve-inputs.outputs.model_version }}-$(date +%Y%m%d%H%M%S)"
          IMAGE_NAME="${ACR_LOGIN_SERVER}/ml-inference:${IMAGE_TAG}"
          IMAGE_LATEST="${ACR_LOGIN_SERVER}/ml-inference:latest"
          
          echo "Image: $IMAGE_NAME"
          
          # Build and push
          cd src
          docker build \
            --build-arg MODEL_VERSION="${{ needs.resolve-inputs.outputs.model_version }}" \
            --build-arg MODEL_NAME="${{ needs.resolve-inputs.outputs.model_name }}" \
            -t "$IMAGE_NAME" \
            -t "$IMAGE_LATEST" \
            -f Dockerfile .
          
          docker push "$IMAGE_NAME"
          docker push "$IMAGE_LATEST"
          
          echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "‚úÖ Image pushed: $IMAGE_NAME"

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.resolve-inputs.outputs.resource_group }} \
            --name ${{ needs.resolve-inputs.outputs.aks_cluster_name }} \
            --overwrite-existing
          
          echo "‚úÖ AKS credentials configured"

      - name: Create namespace
        run: |
          kubectl create namespace ${{ env.AKS_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          echo "‚úÖ Namespace ready: ${{ env.AKS_NAMESPACE }}"

      - name: Update deployment manifest
        run: |
          set -euo pipefail
          
          # Update image and environment variables in deployment manifest
          sed -i "s|image: .*azurecr.io/ml-inference:.*|image: ${{ steps.build_image.outputs.image_name }}|g" kubernetes/ml-inference-deployment.yaml
          sed -i "s|value: \"latest\"|value: \"${{ needs.resolve-inputs.outputs.model_version }}\"|g" kubernetes/ml-inference-deployment.yaml
          sed -i "s|value: \"diabetes_classification\"|value: \"${{ needs.resolve-inputs.outputs.model_name }}\"|g" kubernetes/ml-inference-deployment.yaml
          
          echo "Updated manifest:"
          grep -A 5 "image:" kubernetes/ml-inference-deployment.yaml
          grep -A 3 "MODEL_VERSION" kubernetes/ml-inference-deployment.yaml

      - name: Clean up stuck pods (if any)
        run: |
          echo "Checking for stuck/pending pods..."
          
          # Delete any pending pods older than 5 minutes
          STUCK_PODS=$(kubectl get pods -n ${{ env.AKS_NAMESPACE }} -l app=ml-inference --field-selector=status.phase=Pending -o json | jq -r '.items[] | select(.metadata.creationTimestamp | fromdateiso8601 < (now - 300)) | .metadata.name')
          
          if [ -n "$STUCK_PODS" ]; then
            echo "Found stuck pods, deleting:"
            echo "$STUCK_PODS"
            echo "$STUCK_PODS" | xargs -r kubectl delete pod -n ${{ env.AKS_NAMESPACE }}
            sleep 10
          else
            echo "No stuck pods found"
          fi

      - name: Deploy to AKS
        id: deploy
        run: |
          set -euo pipefail
          
          if kubectl get deployment ml-inference -n ${{ env.AKS_NAMESPACE }} >/dev/null 2>&1; then
            echo "Deployment exists - updating with new image..."
            
            # Apply the updated manifest (uses Recreate strategy)
            kubectl apply -f kubernetes/ml-inference-deployment.yaml -n ${{ env.AKS_NAMESPACE }}
            
            # Update image
            kubectl set image deployment/ml-inference \
              inference="${{ steps.build_image.outputs.image_name }}" \
              -n ${{ env.AKS_NAMESPACE }}
          else
            echo "Creating new deployment..."
            kubectl apply -f kubernetes/ml-inference-deployment.yaml -n ${{ env.AKS_NAMESPACE }}
          fi
          
          echo "‚úÖ Deployment initiated (Recreate strategy - will terminate old pods first)"

      - name: Wait for rollout
        id: rollout_status
        run: |
          set -euo pipefail
          
          echo "Waiting for deployment rollout..."
          
          # Increase timeout and add progress feedback
          if kubectl rollout status deployment/ml-inference -n ${{ env.AKS_NAMESPACE }} --timeout=15m; then
            echo "status=succeeded" >> $GITHUB_OUTPUT
            echo "‚úÖ Rollout completed successfully"
          else
            echo "‚ùå Rollout timed out or failed"
            echo "Pod status:"
            kubectl get pods -n ${{ env.AKS_NAMESPACE }} -l app=ml-inference
            echo ""
            echo "Recent events:"
            kubectl get events -n ${{ env.AKS_NAMESPACE }} --sort-by='.lastTimestamp' | tail -20
            exit 1
          fi

      - name: Setup monitoring (ServiceMonitor and Alerts)
        run: |
          set -euo pipefail
          
          echo "üìä Setting up Prometheus monitoring..."
          
          # Apply ServiceMonitor for metrics scraping
          if kubectl apply -f kubernetes/ml-inference-servicemonitor.yaml; then
            echo "‚úÖ ServiceMonitor applied"
          else
            echo "‚ö†Ô∏è ServiceMonitor application failed (Prometheus Operator may not be installed)"
            echo "To install Prometheus Operator, run: kubectl apply -f scripts/setup-monitoring.sh"
          fi
          
          # Apply Alert Rules
          if kubectl apply -f kubernetes/ml-inference-alerts.yaml; then
            echo "‚úÖ Alert rules applied"
          else
            echo "‚ö†Ô∏è Alert rules application failed (Prometheus Operator may not be installed)"
          fi
          
          # Verify monitoring setup
          echo ""
          echo "Monitoring Status:"
          kubectl get servicemonitor -n ${{ env.AKS_NAMESPACE }} -l app=ml-inference || echo "ServiceMonitor not found (requires Prometheus Operator)"
          kubectl get prometheusrule -n ${{ env.AKS_NAMESPACE }} -l app=ml-inference || echo "PrometheusRule not found (requires Prometheus Operator)"
          
          echo ""
          echo "üìà Metrics endpoint: http://ml-inference-svc:5001/metrics"
          echo "To access Prometheus + Grafana, run: bash scripts/setup-monitoring.sh"

      - name: Get service external IP
        id: get_service_ip
        run: |
          set -euo pipefail
          
          echo "Waiting for LoadBalancer to assign external IP..."
          
          for i in {1..60}; do
            EXTERNAL_IP=$(kubectl get service ml-inference -n ${{ env.AKS_NAMESPACE }} \
              -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            
            if [ -n "$EXTERNAL_IP" ]; then
              echo "EXTERNAL_IP=$EXTERNAL_IP" >> $GITHUB_OUTPUT
              echo "‚úÖ Service URL: http://${EXTERNAL_IP}"
              break
            fi
            
            echo "Waiting for external IP... ($i/60)"
            sleep 10
          done
          
          if [ -z "$EXTERNAL_IP" ]; then
            echo "::warning::Timeout waiting for external IP"
            echo "EXTERNAL_IP=pending" >> $GITHUB_OUTPUT
          fi

      - name: Verify pod health
        run: |
          set -euo pipefail
          
          echo "Checking pod status..."
          kubectl get pods -n ${{ env.AKS_NAMESPACE }} -l app=ml-inference
          
          echo ""
          echo "Pod logs (last 50 lines):"
          POD_NAME=$(kubectl get pods -n ${{ env.AKS_NAMESPACE }} -l app=ml-inference -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -n "$POD_NAME" ]; then
            kubectl logs "$POD_NAME" -n ${{ env.AKS_NAMESPACE }} --tail=50 || echo "Could not retrieve logs"
          else
            echo "No pods found"
          fi
          
          echo ""
          echo "Checking pod readiness..."
          READY_PODS=$(kubectl get pods -n ${{ env.AKS_NAMESPACE }} -l app=ml-inference \
            --field-selector=status.phase=Running 2>/dev/null | grep -c "1/1" || echo "0")
          
          echo "Ready pods: $READY_PODS"
          
          if [ "$READY_PODS" -eq 0 ]; then
            echo "::warning::No pods fully ready yet, but continuing..."
            kubectl get pods -n ${{ env.AKS_NAMESPACE }} -l app=ml-inference
          fi

      - name: Run smoke tests
        if: steps.get_service_ip.outputs.EXTERNAL_IP != 'pending'
        run: |
          set -euo pipefail
          
          ENDPOINT_URL="http://${{ steps.get_service_ip.outputs.EXTERNAL_IP }}"
          
          echo "Running smoke tests against: $ENDPOINT_URL"
          
          # Health check with retries
          MAX_RETRIES=3
          for i in $(seq 1 $MAX_RETRIES); do
            if curl -f --max-time 10 "${ENDPOINT_URL}/health"; then
              echo "‚úÖ Health check passed"
              break
            else
              if [ $i -eq $MAX_RETRIES ]; then
                echo "::error::Health check failed after $MAX_RETRIES attempts"
                exit 1
              fi
              echo "Health check attempt $i failed, retrying..."
              sleep 5
            fi
          done
          
          # Prediction test
          RESPONSE=$(curl -X POST "${ENDPOINT_URL}/score" \
            -H "Content-Type: application/json" \
            -d '{"input_data": [[1,78,41,33,311,50.79,0.42,24,0]]}' \
            --max-time 30 -w "\n%{http_code}" -s)
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n-1)
          
          echo "Response code: $HTTP_CODE"
          echo "Response body: $BODY"
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::Prediction test failed with HTTP $HTTP_CODE"
            exit 1
          fi
          
          echo "‚úÖ Smoke tests passed"

      - name: Display deployment summary
        run: |
          echo "### üöÄ Production Deployment (AKS) - Completed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Model**: ${{ needs.resolve-inputs.outputs.model_name }}:${{ needs.resolve-inputs.outputs.model_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image**: ${{ steps.build_image.outputs.image_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Cluster**: ${{ needs.resolve-inputs.outputs.aks_cluster_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Namespace**: ${{ env.AKS_NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.get_service_ip.outputs.EXTERNAL_IP }}" != "pending" ]; then
            echo "**Service URL**: http://${{ steps.get_service_ip.outputs.EXTERNAL_IP }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Status**:" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          kubectl get deployments -n ${{ env.AKS_NAMESPACE }} -l app=ml-inference
          kubectl get pods -n ${{ env.AKS_NAMESPACE }} -l app=ml-inference
          kubectl get service ml-inference -n ${{ env.AKS_NAMESPACE }}
          echo '```' >> $GITHUB_STEP_SUMMARY

  prepare-production:
    name: Prepare Production Blue/Green Deployment (Managed Endpoints - Disabled)
    needs: [resolve-inputs, deploy-staging]
    runs-on: ubuntu-latest
    if: false  # Disabled: Using AKS for production instead
    outputs:
      green_deployment_url: ${{ steps.get_green_endpoint.outputs.DEPLOYMENT_URL }}
      production_ready: ${{ steps.green_status.outputs.ready }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install azure-ai-ml azure-identity

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Install Azure ML CLI extension
        run: |
          az config set extension.use_dynamic_install=yes_without_prompt
          az extension add --name ml --yes --upgrade

      - name: Create or update production endpoint
        id: create_prod_endpoint
        continue-on-error: true
        run: |
          set -euo pipefail
          
          echo "Creating/updating production endpoint: $AZURE_ML_PRODUCTION_ENDPOINT_NAME"
          
          az ml online-endpoint create \
            --name "$AZURE_ML_PRODUCTION_ENDPOINT_NAME" \
            --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
            --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
            --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
            --auth-mode key

      - name: Handle production endpoint creation result
        if: steps.create_prod_endpoint.outcome == 'failure'
        run: |
          echo "::warning::Endpoint may already exist - verifying status..."
          
          status=$(az ml online-endpoint show \
            --name "$AZURE_ML_PRODUCTION_ENDPOINT_NAME" \
            --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
            --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
            --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
            --query provisioning_state -o tsv)
          
          if [ "$status" != "Succeeded" ]; then
            echo "::error::Endpoint exists but is in $status state"
            exit 1
          fi
          
          echo "‚úì Production endpoint already exists and is healthy"

      - name: Check for existing deployments
        id: check_existing
        run: |
          set -euo pipefail
          
          existing_count=$(az ml online-deployment list \
            --endpoint-name "$AZURE_ML_PRODUCTION_ENDPOINT_NAME" \
            --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
            --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
            --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
            --query "length([])" -o tsv)
          
          echo "count=$existing_count" >> $GITHUB_OUTPUT
          echo "Found $existing_count existing deployment(s)"

      - name: Ensure blue deployment exists (first-time setup)
        if: steps.check_existing.outputs.count == '0'
        run: |
          set -euo pipefail
          
          echo "‚ö†Ô∏è  No existing deployments - creating initial BLUE deployment"
          
          az ml online-deployment create \
            --endpoint-name "$AZURE_ML_PRODUCTION_ENDPOINT_NAME" \
            --name "$PROD_BLUE_DEPLOYMENT_NAME" \
            --model "${{ needs.resolve-inputs.outputs.model_name }}:${{ needs.resolve-inputs.outputs.model_version }}" \
            --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
            --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
            --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
            --instance-type Standard_DS3_v2 \
            --instance-count 2 \
            --all-traffic \
            --set environment_variables.DEPLOYMENT_ID="${{ needs.resolve-inputs.outputs.deployment_id }}" \
            --set environment_variables.MODEL_VERSION="${{ needs.resolve-inputs.outputs.model_version }}" \
            --set environment_variables.DEPLOYMENT_COLOR="blue" \
            --tags environment=production \
                   deployment_color=blue \
                   model_name="${{ needs.resolve-inputs.outputs.model_name }}" \
                   model_version="${{ needs.resolve-inputs.outputs.model_version }}" \
            --overwrite
          
          echo "‚úì Initial BLUE deployment created with 100% traffic"

      - name: Create GREEN deployment (no traffic)
        id: create_green
        run: |
          set -euo pipefail
          
          echo "Creating GREEN deployment with new model version"
          
          az ml online-deployment create \
            --endpoint-name "$AZURE_ML_PRODUCTION_ENDPOINT_NAME" \
            --name "$PROD_GREEN_DEPLOYMENT_NAME" \
            --model "${{ needs.resolve-inputs.outputs.model_name }}:${{ needs.resolve-inputs.outputs.model_version }}" \
            --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
            --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
            --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
            --instance-type Standard_DS3_v2 \
            --instance-count 1 \
            --set environment_variables.DEPLOYMENT_ID="${{ needs.resolve-inputs.outputs.deployment_id }}" \
            --set environment_variables.MODEL_VERSION="${{ needs.resolve-inputs.outputs.model_version }}" \
            --set environment_variables.DEPLOYMENT_COLOR="green" \
            --tags environment=production \
                   deployment_color=green \
                   model_name="${{ needs.resolve-inputs.outputs.model_name }}" \
                   model_version="${{ needs.resolve-inputs.outputs.model_version }}" \
            --overwrite

      - name: Wait for GREEN deployment to be ready
        run: |
          set -euo pipefail
          
          echo "‚è≥ Waiting for GREEN deployment to be ready..."
          
          for i in $(seq 1 $MAX_WAIT_ITERATIONS); do
            status=$(az ml online-deployment show \
              --endpoint-name "$AZURE_ML_PRODUCTION_ENDPOINT_NAME" \
              --name "$PROD_GREEN_DEPLOYMENT_NAME" \
              --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
              --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
              --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
              --query provisioning_state -o tsv)
            
            echo "[$i/$MAX_WAIT_ITERATIONS] GREEN deployment state: $status"
            
            if [ "$status" = "Succeeded" ]; then
              echo "‚úì GREEN deployment is ready"
              exit 0
            elif [ "$status" = "Failed" ]; then
              echo "::error::GREEN deployment failed"
              az ml online-deployment show \
                --endpoint-name "$AZURE_ML_PRODUCTION_ENDPOINT_NAME" \
                --name "$PROD_GREEN_DEPLOYMENT_NAME" \
                --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
                --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
                --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
                --query '{state:provisioning_state,error:provisioning_state_error}' -o json
              exit 1
            fi
            
            sleep $WAIT_INTERVAL_SECONDS
          done
          
          echo "::error::Timeout waiting for GREEN deployment"
          exit 1

      - name: Get GREEN deployment details
        id: get_green_endpoint
        run: |
          set -euo pipefail
          
          # Get deployment-specific URL for isolated testing
          DEPLOYMENT_URL=$(az ml online-deployment show \
            --endpoint-name "$AZURE_ML_PRODUCTION_ENDPOINT_NAME" \
            --name "$PROD_GREEN_DEPLOYMENT_NAME" \
            --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
            --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
            --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
            --query scoring_uri -o tsv)
          
          # Get endpoint key and mask it
          ENDPOINT_KEY=$(az ml online-endpoint get-credentials \
            --name "$AZURE_ML_PRODUCTION_ENDPOINT_NAME" \
            --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
            --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
            --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
            --query primaryKey -o tsv)
          
          echo "::add-mask::$ENDPOINT_KEY"
          
          echo "DEPLOYMENT_URL=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          echo "ENDPOINT_KEY=$ENDPOINT_KEY" >> $GITHUB_OUTPUT
          
          echo "‚úì GREEN deployment URL: $DEPLOYMENT_URL"

      - name: Test GREEN deployment in isolation
        env:
          DEPLOYMENT_URL: ${{ steps.get_green_endpoint.outputs.DEPLOYMENT_URL }}
          ENDPOINT_KEY: ${{ steps.get_green_endpoint.outputs.ENDPOINT_KEY }}
        run: |
          set -euo pipefail
          
          echo "üß™ Testing GREEN deployment in isolation (before receiving traffic)..."
          
          if [ ! -f "scripts/test_endpoint.py" ]; then
            echo "::warning::Test script not found - skipping isolated tests"
            exit 0
          fi
          
          python scripts/test_endpoint.py --url "$DEPLOYMENT_URL" --key "$ENDPOINT_KEY"
          
          echo "‚úì GREEN deployment tests passed"

      - name: Show current traffic distribution
        run: |
          echo "üìä Current production traffic distribution:"
          az ml online-endpoint show \
            --name "$AZURE_ML_PRODUCTION_ENDPOINT_NAME" \
            --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
            --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
            --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
            --query traffic -o json

      - name: Set production readiness status
        id: green_status
        run: |
          echo "ready=true" >> $GITHUB_OUTPUT

      - name: Update preparation summary
        run: |
          echo "### üéØ Production Preparation Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ GREEN deployment created and validated" >> $GITHUB_STEP_SUMMARY
          echo "üîó **Deployment URL**: ${{ steps.get_green_endpoint.outputs.DEPLOYMENT_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚ö†Ô∏è  **Current status**: GREEN has 0% traffic (awaiting approval for rollout)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next step**: Manual approval required to begin gradual traffic shift"

  await-production-approval:
    name: üîí Await Production Approval
    needs: [resolve-inputs, deploy-staging]
    runs-on: ubuntu-latest
    environment:
      name: production-approval  # GitHub environment protection rule required
      url: ${{ needs.deploy-staging.outputs.endpoint_url }}
    steps:
      - name: Display approval information
        run: |
          echo "### üîí Production Deployment Approval Required" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Staging deployment**: Successful" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Staging tests**: Passed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Details:**" >> $GITHUB_STEP_SUMMARY
          echo "- Model: ${{ needs.resolve-inputs.outputs.model_name }}:${{ needs.resolve-inputs.outputs.model_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- Deployment ID: ${{ needs.resolve-inputs.outputs.deployment_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- Staging URL: ${{ needs.deploy-staging.outputs.endpoint_url }}" >> $GITHUB_STEP_SUMMARY
          echo "- Target: Production AKS Cluster (${{ needs.resolve-inputs.outputs.aks_cluster_name }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Production Deployment Plan:**" >> $GITHUB_STEP_SUMMARY
          echo "1. Build Docker image with model embedded" >> $GITHUB_STEP_SUMMARY
          echo "2. Push image to ACR (${{ needs.resolve-inputs.outputs.acr_name }})" >> $GITHUB_STEP_SUMMARY
          echo "3. Deploy to AKS with rolling update strategy" >> $GITHUB_STEP_SUMMARY
          echo "4. Expose via LoadBalancer service" >> $GITHUB_STEP_SUMMARY
          echo "5. Run smoke tests against production endpoint" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚ö†Ô∏è  **Approve this deployment to proceed with production rollout to AKS**"

  setup-monitoring-stack:
    name: üìä Setup Monitoring Stack (Optional)
    needs: [resolve-inputs, await-production-approval]
    runs-on: ubuntu-latest
    if: inputs.setup_monitoring == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.resolve-inputs.outputs.resource_group }} \
            --name ${{ needs.resolve-inputs.outputs.aks_cluster_name }} \
            --overwrite-existing
          echo "‚úÖ AKS credentials configured"

      - name: Add Helm repositories
        run: |
          echo "üì¶ Adding Helm repositories..."
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo add jetstack https://charts.jetstack.io
          helm repo update
          echo "‚úÖ Helm repositories added"

      - name: Install cert-manager
        run: |
          echo "üîê Installing cert-manager..."
          
          # Check if cert-manager is already installed
          if helm list -n cert-manager | grep -q cert-manager; then
            echo "‚è≠Ô∏è  cert-manager already installed"
          else
            kubectl create namespace cert-manager --dry-run=client -o yaml | kubectl apply -f -
            
            helm install cert-manager jetstack/cert-manager \
              --namespace cert-manager \
              --version v1.13.2 \
              --set installCRDs=true \
              --wait --timeout 5m
            
            echo "‚úÖ cert-manager installed"
          fi

      - name: Install Prometheus + Grafana stack
        run: |
          echo "üìä Installing kube-prometheus-stack..."
          
          # Check if prometheus is already installed
          if helm list -n monitoring | grep -q kube-prometheus-stack; then
            echo "‚è≠Ô∏è  kube-prometheus-stack already installed"
          else
            kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -
            
            # Install with minimal resource requirements for small clusters
            echo "Installing with reduced resources for constrained clusters..."
            helm install kube-prometheus-stack prometheus-community/kube-prometheus-stack \
              --namespace monitoring \
              --set prometheus.prometheusSpec.serviceMonitorSelectorNilUsesHelmValues=false \
              --set prometheus.prometheusSpec.replicas=1 \
              --set prometheus.prometheusSpec.resources.requests.cpu=100m \
              --set prometheus.prometheusSpec.resources.requests.memory=200Mi \
              --set prometheus.prometheusSpec.resources.limits.memory=1Gi \
              --set grafana.adminPassword=Admin123! \
              --set grafana.service.type=LoadBalancer \
              --set grafana.replicas=1 \
              --set grafana.resources.requests.cpu=100m \
              --set grafana.resources.requests.memory=100Mi \
              --set grafana.resources.limits.memory=500Mi \
              --set prometheus.service.type=LoadBalancer \
              --set alertmanager.enabled=true \
              --set alertmanager.alertmanagerSpec.replicas=1 \
              --set alertmanager.alertmanagerSpec.resources.requests.cpu=50m \
              --set alertmanager.alertmanagerSpec.resources.requests.memory=100Mi \
              --set alertmanager.alertmanagerSpec.resources.limits.memory=500Mi \
              --set prometheusOperator.resources.requests.cpu=50m \
              --set prometheusOperator.resources.requests.memory=100Mi \
              --set kube-state-metrics.resources.requests.cpu=10m \
              --set kube-state-metrics.resources.requests.memory=50Mi \
              --timeout 25m || {
                echo "‚ö†Ô∏è  Monitoring stack installation failed (likely resource constraints)"
                echo "Your cluster may be too small. Consider:"
                echo "  1. Scale AKS cluster: az aks scale --node-count 2"
                echo "  2. Use manual setup after deployment"
                echo "  3. Deploy monitoring to separate cluster"
                exit 1
              }
            
            echo "‚úÖ kube-prometheus-stack installed"
          fi

      - name: Wait for Prometheus Operator
        run: |
          echo "‚è≥ Waiting for Prometheus Operator to be ready..."
          
          # Wait with retries
          for i in {1..10}; do
            if kubectl wait --for=condition=ready pod \
              -l app.kubernetes.io/name=prometheus-operator \
              -n monitoring \
              --timeout=60s 2>/dev/null; then
              echo "‚úÖ Prometheus Operator ready"
              break
            fi
            echo "Attempt $i/10 - Operator not ready yet..."
            kubectl get pods -n monitoring -l app.kubernetes.io/name=prometheus-operator
            sleep 30
          done
          
          echo ""
          echo "All monitoring pods:"
          kubectl get pods -n monitoring

      - name: Apply ServiceMonitor and Alerts
        run: |
          echo "üìà Applying ServiceMonitor and Alert rules..."
          
          # Wait a bit more for CRDs to be fully registered
          sleep 10
          
          # Apply ServiceMonitor
          if kubectl apply -f kubernetes/ml-inference-servicemonitor.yaml; then
            echo "‚úÖ ServiceMonitor applied"
          else
            echo "‚ö†Ô∏è  ServiceMonitor failed (will retry in 30s)"
            sleep 30
            kubectl apply -f kubernetes/ml-inference-servicemonitor.yaml
          fi
          
          # Apply Alert Rules
          if kubectl apply -f kubernetes/ml-inference-alerts.yaml; then
            echo "‚úÖ Alert rules applied"
          else
            echo "‚ö†Ô∏è  Alert rules failed (will retry in 30s)"
            sleep 30
            kubectl apply -f kubernetes/ml-inference-alerts.yaml
          fi

      - name: Import Grafana Dashboard
        run: |
          echo "üìä Waiting for Grafana to be ready..."
          kubectl wait --for=condition=ready pod \
            -l app.kubernetes.io/name=grafana \
            -n monitoring \
            --timeout=300s || true
          
          echo "Grafana pods:"
          kubectl get pods -n monitoring -l app.kubernetes.io/name=grafana
          
          echo ""
          echo "‚ÑπÔ∏è  To import the ML Inference dashboard:"
          echo "   1. Access Grafana (see below for URL)"
          echo "   2. Go to Dashboards ‚Üí Import"
          echo "   3. Upload kubernetes/grafana-dashboard.json"
          echo "   4. Select Prometheus data source"

      - name: Display access information
        run: |
          echo "### üìä Monitoring Stack Deployed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Components Installed:**" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Prometheus Operator" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Prometheus Server" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Grafana" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ cert-manager" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ ServiceMonitor (ML Inference metrics)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Alert Rules (Error rate, Latency)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Get Grafana LoadBalancer IP
          echo "‚è≥ Waiting for Grafana LoadBalancer IP..."
          for i in {1..30}; do
            GRAFANA_IP=$(kubectl get svc -n monitoring kube-prometheus-stack-grafana -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            if [ -n "$GRAFANA_IP" ]; then
              echo "GRAFANA_URL=http://$GRAFANA_IP" >> $GITHUB_ENV
              echo "**Access URLs:**" >> $GITHUB_STEP_SUMMARY
              echo "- üìä Grafana: http://$GRAFANA_IP (admin / Admin123!)" >> $GITHUB_STEP_SUMMARY
              break
            fi
            sleep 10
          done
          
          if [ -z "$GRAFANA_IP" ]; then
            echo "‚ö†Ô∏è  **Grafana LoadBalancer IP not ready yet**" >> $GITHUB_STEP_SUMMARY
            echo "   Run: \`kubectl get svc -n monitoring kube-prometheus-stack-grafana\`" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
          echo "1. Access Grafana using the URL above" >> $GITHUB_STEP_SUMMARY
          echo "2. Import dashboard from \`kubernetes/grafana-dashboard.json\`" >> $GITHUB_STEP_SUMMARY
          echo "3. (Optional) Setup NGINX Ingress with OAuth2 for secure access" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚ÑπÔ∏è  To setup ingress, set \`setup_ingress: true\` in next run" >> $GITHUB_STEP_SUMMARY

  setup-ingress-dashboards:
    name: üåê Setup Dashboard Ingress (Optional)
    needs: [resolve-inputs, await-production-approval, setup-monitoring-stack]
    runs-on: ubuntu-latest
    if: inputs.setup_ingress == 'true' && inputs.setup_monitoring == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.resolve-inputs.outputs.resource_group }} \
            --name ${{ needs.resolve-inputs.outputs.aks_cluster_name }} \
            --overwrite-existing

      - name: Install NGINX Ingress Controller
        run: |
          echo "üåê Installing NGINX Ingress Controller..."
          
          if helm list -n ingress-nginx | grep -q ingress-nginx; then
            echo "‚è≠Ô∏è  NGINX Ingress already installed"
          else
            kubectl create namespace ingress-nginx --dry-run=client -o yaml | kubectl apply -f -
            
            helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
            helm repo update
            
            helm install ingress-nginx ingress-nginx/ingress-nginx \
              --namespace ingress-nginx \
              --set controller.service.type=LoadBalancer \
              --wait --timeout 10m
            
            echo "‚úÖ NGINX Ingress Controller installed"
          fi

      - name: Deploy OAuth2 Proxy
        run: |
          echo "üîê Deploying OAuth2 Proxy..."
          
          # Create secret with Azure AD credentials (if secrets are configured)
          if [ -n "${{ secrets.AZURE_AD_CLIENT_ID }}" ] && [ -n "${{ secrets.AZURE_AD_CLIENT_SECRET }}" ]; then
            kubectl create secret generic oauth2-proxy-secrets \
              --from-literal=client-id="${{ secrets.AZURE_AD_CLIENT_ID }}" \
              --from-literal=client-secret="${{ secrets.AZURE_AD_CLIENT_SECRET }}" \
              --from-literal=cookie-secret="$(openssl rand -base64 32)" \
              --namespace monitoring \
              --dry-run=client -o yaml | kubectl apply -f -
            
            kubectl apply -f kubernetes/ingress/oauth2-proxy.yaml
            echo "‚úÖ OAuth2 Proxy deployed with Azure AD"
          else
            echo "‚ö†Ô∏è  AZURE_AD_CLIENT_ID and AZURE_AD_CLIENT_SECRET not configured"
            echo "   Skipping OAuth2 Proxy deployment"
            echo "   Add these secrets to enable Azure AD authentication"
          fi

      - name: Apply Ingress Rules
        run: |
          echo "üåê Applying Ingress rules..."
          
          # Apply Grafana Ingress
          kubectl apply -f kubernetes/ingress/grafana-ingress.yaml || echo "‚ö†Ô∏è  Grafana ingress failed (check cert-manager ClusterIssuer)"
          
          # Apply Prometheus Ingress
          kubectl apply -f kubernetes/ingress/prometheus-ingress.yaml || echo "‚ö†Ô∏è  Prometheus ingress failed (check cert-manager ClusterIssuer)"
          
          echo "‚úÖ Ingress rules applied"

      - name: Get Ingress IP
        run: |
          echo "‚è≥ Waiting for Ingress Controller IP..."
          for i in {1..30}; do
            INGRESS_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            if [ -n "$INGRESS_IP" ]; then
              echo "### üåê Dashboard Ingress Deployed" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Ingress Controller IP:** $INGRESS_IP" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Setup Instructions:**" >> $GITHUB_STEP_SUMMARY
              echo "1. Add DNS records:" >> $GITHUB_STEP_SUMMARY
              echo "   - grafana.yourdomain.com ‚Üí $INGRESS_IP" >> $GITHUB_STEP_SUMMARY
              echo "   - prometheus.yourdomain.com ‚Üí $INGRESS_IP" >> $GITHUB_STEP_SUMMARY
              echo "2. Update ingress files with your domain names" >> $GITHUB_STEP_SUMMARY
              echo "3. Configure Azure AD app registration for OAuth2" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "‚ÑπÔ∏è  See \`DASHBOARD_EXPOSURE_GUIDE.md\` for detailed setup" >> $GITHUB_STEP_SUMMARY
              break
            fi
            sleep 10
          done
          
          if [ -z "$INGRESS_IP" ]; then
            echo "‚ö†Ô∏è  Ingress IP not ready yet" >> $GITHUB_STEP_SUMMARY
            echo "   Run: \`kubectl get svc -n ingress-nginx\`" >> $GITHUB_STEP_SUMMARY
          fi

  gradual-rollout:
    name: üöÄ Gradual Blue‚ÜíGreen Traffic Rollout (Managed Endpoints - Disabled)
    needs: [resolve-inputs, await-production-approval]
    runs-on: ubuntu-latest
    if: false  # Disabled: Using AKS rolling update for production
    environment:
      name: production
      url: https://portal.azure.com/#@/resource/subscriptions/${{ needs.resolve-inputs.outputs.subscription_id }}/resourceGroups/${{ needs.resolve-inputs.outputs.resource_group }}/providers/Microsoft.MachineLearningServices/workspaces/${{ needs.resolve-inputs.outputs.aml_workspace }}/endpoints/${{ env.AZURE_ML_PRODUCTION_ENDPOINT_NAME }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install azure-ai-ml azure-identity

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Install Azure ML CLI extension
        run: |
          az config set extension.use_dynamic_install=yes_without_prompt
          az extension add --name ml --yes --upgrade

      - name: Execute gradual traffic shift with validation
        id: rollout
        env:
          ENDPOINT_NAME: ${{ env.AZURE_ML_PRODUCTION_ENDPOINT_NAME }}
          BLUE: ${{ env.PROD_BLUE_DEPLOYMENT_NAME }}
          GREEN: ${{ env.PROD_GREEN_DEPLOYMENT_NAME }}
          WORKSPACE: ${{ needs.resolve-inputs.outputs.aml_workspace }}
          RESOURCE_GROUP: ${{ needs.resolve-inputs.outputs.resource_group }}
          SUBSCRIPTION: ${{ needs.resolve-inputs.outputs.subscription_id }}
        run: |
          set -euo pipefail
          
          echo "üöÄ Starting gradual rollout from BLUE to GREEN"
          
          # Function to run smoke tests
          smoke_test() {
            local test_name="$1"
            
            echo "üß™ Running smoke test: $test_name"
            
            ENDPOINT_URL=$(az ml online-endpoint show \
              --name "$ENDPOINT_NAME" \
              --workspace-name "$WORKSPACE" \
              --resource-group "$RESOURCE_GROUP" \
              --subscription "$SUBSCRIPTION" \
              --query scoring_uri -o tsv)
            
            KEY=$(az ml online-endpoint get-credentials \
              --name "$ENDPOINT_NAME" \
              --workspace-name "$WORKSPACE" \
              --resource-group "$RESOURCE_GROUP" \
              --subscription "$SUBSCRIPTION" \
              --query primaryKey -o tsv)
            
            echo "::add-mask::$KEY"
            
            if [ ! -f "scripts/test_endpoint.py" ]; then
              echo "::warning::Test script not found - skipping smoke test"
              return 0
            fi
            
            if python scripts/test_endpoint.py --url "$ENDPOINT_URL" --key "$KEY"; then
              echo "‚úÖ Smoke test passed: $test_name"
              return 0
            else
              echo "::error::Smoke test failed: $test_name"
              return 1
            fi
          }
          
          # Function to rollback to BLUE
          rollback_to_blue() {
            local reason="$1"
            
            echo "::error::‚ùå ROLLBACK INITIATED: $reason"
            echo "Rolling back: routing 100% traffic to BLUE ($BLUE)"
            
            az ml online-endpoint update \
              --name "$ENDPOINT_NAME" \
              --workspace-name "$WORKSPACE" \
              --resource-group "$RESOURCE_GROUP" \
              --subscription "$SUBSCRIPTION" \
              --traffic "{\"$BLUE\":100}"
            
            echo "‚úì Rollback complete - 100% traffic routed to BLUE"
            echo "rollback_performed=true" >> $GITHUB_OUTPUT
          }
          
          # Function to update traffic
          update_traffic() {
            local blue_pct=$1
            local green_pct=$2
            
            echo "üîÑ Shifting traffic: BLUE=$blue_pct%, GREEN=$green_pct%"
            
            if [ "$blue_pct" -eq 0 ]; then
              TRAFFIC_JSON="{\"$GREEN\":$green_pct}"
            else
              TRAFFIC_JSON="{\"$BLUE\":$blue_pct,\"$GREEN\":$green_pct}"
            fi
            
            echo "Applying traffic: $TRAFFIC_JSON"
            
            az ml online-endpoint update \
              --name "$ENDPOINT_NAME" \
              --workspace-name "$WORKSPACE" \
              --resource-group "$RESOURCE_GROUP" \
              --subscription "$SUBSCRIPTION" \
              --traffic "$TRAFFIC_JSON"
            
            echo "‚è≥ Waiting 30s for traffic propagation and metrics collection..."
            sleep 30
          }
          
          # Initialize rollback flag
          echo "rollback_performed=false" >> $GITHUB_OUTPUT
          
          # Phase 1: 10% GREEN traffic
          echo "üìä Phase 1: Shifting 10% traffic to GREEN"
          if ! update_traffic 90 10; then
            rollback_to_blue "Failed to update traffic to 10%"
            exit 1
          fi
          
          if ! smoke_test "10% traffic on GREEN"; then
            rollback_to_blue "Smoke test failed at 10%"
            exit 1
          fi
          
          echo "‚úÖ Phase 1 complete: 10% traffic validated"
          
          # Phase 2: 50% GREEN traffic
          echo "üìä Phase 2: Shifting 50% traffic to GREEN"
          if ! update_traffic 50 50; then
            rollback_to_blue "Failed to update traffic to 50%"
            exit 1
          fi
          
          if ! smoke_test "50% traffic on GREEN"; then
            rollback_to_blue "Smoke test failed at 50%"
            exit 1
          fi
          
          echo "‚úÖ Phase 2 complete: 50% traffic validated"
          
          # Phase 3: 100% GREEN traffic
          echo "üìä Phase 3: Shifting 100% traffic to GREEN"
          if ! update_traffic 0 100; then
            rollback_to_blue "Failed to update traffic to 100%"
            exit 1
          fi
          
          if ! smoke_test "100% traffic on GREEN"; then
            rollback_to_blue "Smoke test failed at 100%"
            exit 1
          fi
          
          echo "‚úÖ Phase 3 complete: 100% traffic validated"
          echo "üéâ Rollout successful! GREEN deployment now serving 100% of production traffic"

      - name: Scale down BLUE deployment for cost savings
        if: success()
        continue-on-error: true
        run: |
          echo "üí∞ Scaling BLUE deployment to 0 instances for cost optimization"
          
          az ml online-deployment update \
            --endpoint-name "${{ env.AZURE_ML_PRODUCTION_ENDPOINT_NAME }}" \
            --name "${{ env.PROD_BLUE_DEPLOYMENT_NAME }}" \
            --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
            --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
            --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
            --instance-count 0
          
          echo "‚úì BLUE deployment scaled to 0 (kept for quick rollback if needed)"

      - name: Update rollout summary
        if: always()
        run: |
          echo "### üìä Production Rollout Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.rollout.outputs.rollback_performed }}" = "true" ]; then
            echo "‚ùå **Status**: Rollout failed - rolled back to BLUE" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è  **Current state**: 100% traffic on BLUE deployment" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Action required**: Investigate failure, fix issues, and retry deployment" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ **Status**: Rollout successful" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üéâ **Current state**: 100% traffic on GREEN deployment" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Rollout phases completed:**" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ 10% traffic ‚Üí validated" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ 50% traffic ‚Üí validated" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ 100% traffic ‚Üí validated" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üí∞ BLUE deployment scaled to 0 instances for cost savings" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Status**: Rollout failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment details:**" >> $GITHUB_STEP_SUMMARY
          echo "- Model: ${{ needs.resolve-inputs.outputs.model_name }}:${{ needs.resolve-inputs.outputs.model_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- Deployment ID: ${{ needs.resolve-inputs.outputs.deployment_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- Endpoint: ${{ env.AZURE_ML_PRODUCTION_ENDPOINT_NAME }}" >> $GITHUB_STEP_SUMMARY

  post-deployment-validation:
    name: üîç Post-Deployment Validation
    needs: [resolve-inputs, gradual-rollout]
    runs-on: ubuntu-latest
    if: success()
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Install Azure ML CLI extension
        run: |
          az config set extension.use_dynamic_install=yes_without_prompt
          az extension add --name ml --yes --upgrade

      - name: Verify final traffic distribution
        run: |
          echo "üìä Verifying final traffic distribution"
          
          traffic=$(az ml online-endpoint show \
            --name "${{ env.AZURE_ML_PRODUCTION_ENDPOINT_NAME }}" \
            --workspace-name "${{ needs.resolve-inputs.outputs.aml_workspace }}" \
            --resource-group "${{ needs.resolve-inputs.outputs.resource_group }}" \
            --subscription "${{ needs.resolve-inputs.outputs.subscription_id }}" \
            --query traffic -o json)
          
          echo "Current traffic: $traffic"
          
          green_traffic=$(echo "$traffic" | jq -r '.["${{ env.PROD_GREEN_DEPLOYMENT_NAME }}"] // 0')
          
          if [ "$green_traffic" != "100" ]; then
            echo "::error::Expected GREEN to have 100% traffic, but got $green_traffic%"
            exit 1
          fi
          
          echo "‚úÖ Verified: GREEN deployment has 100% traffic"

      - name: Log deployment metrics
        run: |
          echo "### üìà Deployment Metrics" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Deployment Timestamp | $(date -u +%Y-%m-%dT%H:%M:%SZ) |" >> $GITHUB_STEP_SUMMARY
          echo "| Model Name | ${{ needs.resolve-inputs.outputs.model_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Model Version | ${{ needs.resolve-inputs.outputs.model_version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deployment ID | ${{ needs.resolve-inputs.outputs.deployment_id }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deployed By | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Workflow Run | [${{ github.run_id }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) |" >> $GITHUB_STEP_SUMMARY
          echo "| Infrastructure | DEV (mlopsnew-dev-*) |" >> $GITHUB_STEP_SUMMARY
          echo "| Instance Type | Standard_DS3_v2 |" >> $GITHUB_STEP_SUMMARY
          echo "| Instance Count | 2 (Blue/Green deployments) |" >> $GITHUB_STEP_SUMMARY

      - name: Notify deployment success
        if: always()
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const summary = `
            ## üéâ Production Deployment Successful
            
            **Model**: ${{ needs.resolve-inputs.outputs.model_name }}:${{ needs.resolve-inputs.outputs.model_version }}
            **Deployment ID**: ${{ needs.resolve-inputs.outputs.deployment_id }}
            **Endpoint**: ${{ env.AZURE_ML_PRODUCTION_ENDPOINT_NAME }}
            **Deployed by**: @${{ github.actor }}
            
            ‚úÖ Gradual rollout completed: 10% ‚Üí 50% ‚Üí 100%
            ‚úÖ All smoke tests passed
            ‚úÖ GREEN deployment now serving 100% production traffic
            `;
            
            console.log(summary);
