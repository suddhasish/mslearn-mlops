# GitHub Actions - Infrastructure Deployment
# Deploys complete MLOps infrastructure using Terraform

name: Infrastructure Deployment

on:
  push:
    branches:
      - main
      - deployment-pipeline
    paths:
      - 'infrastructure/**'
      - '.github/workflows/infrastructure-deploy.yml'
  pull_request:
    branches:
      - main
      - deployment-pipeline
    paths:
      - 'infrastructure/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options:
          - dev
          - prod
      destroy:
        description: 'Destroy infrastructure'
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  pull-requests: write
  issues: write

env:
  TERRAFORM_VERSION: '1.6.0'
  WORKING_DIR_DEV: './infrastructure/environments/dev'
  WORKING_DIR_PROD: './infrastructure/environments/prod'

jobs:
  terraform-validate:
    name: Validate Terraform
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Terraform Format Check
        run: |
          cd ./infrastructure
          terraform fmt -check -recursive
        continue-on-error: true

      - name: Terraform Init Dev (no backend)
        run: |
          cd ${{ env.WORKING_DIR_DEV }}
          terraform init -backend=false

      - name: Terraform Validate Dev
        run: |
          cd ${{ env.WORKING_DIR_DEV }}
          terraform validate

      - name: Terraform Init Prod (no backend)
        run: |
          cd ${{ env.WORKING_DIR_PROD }}
          terraform init -backend=false

      - name: Terraform Validate Prod
        run: |
          cd ${{ env.WORKING_DIR_PROD }}
          terraform validate

      - name: Upload Terraform configs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-configs
          path: ./infrastructure/environments

  terraform-destroy-dev:
    name: Destroy - Development
    needs: terraform-validate
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'dev' && github.event.inputs.destroy == 'true'
    environment:
      name: dev-destroy
      url: https://portal.azure.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CLIENT_SECRET }}

      - name: Setup Terraform Environment Variables
        run: |
          echo "ARM_CLIENT_ID=${{ fromJson(secrets.AZURE_CLIENT_SECRET).clientId }}" >> $GITHUB_ENV
          echo "ARM_CLIENT_SECRET=${{ fromJson(secrets.AZURE_CLIENT_SECRET).clientSecret }}" >> $GITHUB_ENV
          echo "ARM_SUBSCRIPTION_ID=${{ fromJson(secrets.AZURE_CLIENT_SECRET).subscriptionId }}" >> $GITHUB_ENV
          echo "ARM_TENANT_ID=${{ fromJson(secrets.AZURE_CLIENT_SECRET).tenantId }}" >> $GITHUB_ENV

      - name: Prepare terraform.tfvars with secrets
        run: |
          cd ${{ env.WORKING_DIR_DEV }}
          
          # Replace secret placeholders with actual values or defaults
          PROJECT_NAME="${{ secrets.PROJECT_NAME }}"
          if [ -z "$PROJECT_NAME" ]; then
            PROJECT_NAME="mlops-dev"
          fi
          
          LOCATION="${{ secrets.AZURE_LOCATION }}"
          if [ -z "$LOCATION" ]; then
            LOCATION="eastus"
          fi
          
          NOTIFICATION_EMAIL="${{ secrets.NOTIFICATION_EMAIL }}"
          if [ -z "$NOTIFICATION_EMAIL" ]; then
            NOTIFICATION_EMAIL="devops@example.com"
          fi
          
          sed -i "s/VAR_PROJECT_NAME/$PROJECT_NAME/g" terraform.tfvars
          sed -i "s/VAR_AZURE_LOCATION/$LOCATION/g" terraform.tfvars
          sed -i "s/VAR_NOTIFICATION_EMAIL/$NOTIFICATION_EMAIL/g" terraform.tfvars
          
          echo "âœ… Using environments/dev/terraform.tfvars with secrets injected"

      - name: Terraform Init
        run: |
          cd ${{ env.WORKING_DIR_DEV }}
          terraform init

      - name: Terraform Destroy
        run: |
          cd ${{ env.WORKING_DIR_DEV }}
          echo "âš ï¸ DESTROYING ALL INFRASTRUCTURE IN DEV ENVIRONMENT..."
          terraform destroy -auto-approve

      - name: Create Destroy Summary
        run: |
          echo "## ðŸ—‘ï¸ Infrastructure Destroyed - Development" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All infrastructure resources in the dev environment have been destroyed." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Destroyed by:** @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u)" >> $GITHUB_STEP_SUMMARY

  terraform-destroy-prod:
    name: Destroy - Production
    needs: terraform-validate
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod' && github.event.inputs.destroy == 'true'
    environment:
      name: production-destroy
      url: https://portal.azure.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CLIENT_SECRET }}

      - name: Setup Terraform Environment Variables
        run: |
          echo "ARM_CLIENT_ID=${{ fromJson(secrets.AZURE_CLIENT_SECRET).clientId }}" >> $GITHUB_ENV
          echo "ARM_CLIENT_SECRET=${{ fromJson(secrets.AZURE_CLIENT_SECRET).clientSecret }}" >> $GITHUB_ENV
          echo "ARM_SUBSCRIPTION_ID=${{ fromJson(secrets.AZURE_CLIENT_SECRET).subscriptionId }}" >> $GITHUB_ENV
          echo "ARM_TENANT_ID=${{ fromJson(secrets.AZURE_CLIENT_SECRET).tenantId }}" >> $GITHUB_ENV

      - name: Prepare terraform.tfvars with secrets
        run: |
          cd ${{ env.WORKING_DIR_PROD }}
          
          # Replace secret placeholders with actual values or defaults
          PROJECT_NAME="${{ secrets.PROJECT_NAME }}"
          if [ -z "$PROJECT_NAME" ]; then
            PROJECT_NAME="mlops-prod"
          fi
          
          LOCATION="${{ secrets.AZURE_LOCATION }}"
          if [ -z "$LOCATION" ]; then
            LOCATION="eastus"
          fi
          
          NOTIFICATION_EMAIL="${{ secrets.NOTIFICATION_EMAIL }}"
          if [ -z "$NOTIFICATION_EMAIL" ]; then
            NOTIFICATION_EMAIL="devops@example.com"
          fi
          
          sed -i "s/VAR_PROJECT_NAME/$PROJECT_NAME/g" terraform.tfvars
          sed -i "s/VAR_AZURE_LOCATION/$LOCATION/g" terraform.tfvars
          sed -i "s/VAR_NOTIFICATION_EMAIL/$NOTIFICATION_EMAIL/g" terraform.tfvars
          
          echo "âœ… Using environments/prod/terraform.tfvars with secrets injected"

      - name: Terraform Init
        run: |
          cd ${{ env.WORKING_DIR_PROD }}
          terraform init

      - name: Terraform Destroy
        run: |
          cd ${{ env.WORKING_DIR_PROD }}
          echo "âš ï¸ DESTROYING ALL INFRASTRUCTURE IN PROD ENVIRONMENT..."
          terraform destroy -auto-approve

      - name: Create Destroy Summary
        run: |
          echo "## ðŸ—‘ï¸ Infrastructure Destroyed - Production" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âš ï¸ All infrastructure resources in the PRODUCTION environment have been destroyed." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Destroyed by:** @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u)" >> $GITHUB_STEP_SUMMARY

  terraform-plan-dev:
    name: Plan - Development
    needs: terraform-validate
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'dev')
    environment: 
      name: dev-plan
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CLIENT_SECRET }}

      - name: Validate required secrets
        run: |
          set -e
          MISSING=0
          if [ -z "${{ secrets.PROJECT_NAME }}" ]; then
            echo "Error: PROJECT_NAME secret is not set. Please add it in Settings > Secrets and variables > Actions." >&2
            MISSING=1
          fi
          if [ -z "${{ secrets.AZURE_CLIENT_SECRET }}" ]; then
            echo "Error: AZURE_CLIENT_SECRET secret is not set." >&2
            MISSING=1
          fi
          if [ $MISSING -ne 0 ]; then
            exit 1
          fi

      - name: Setup Terraform Environment Variables
        run: |
          echo "ARM_CLIENT_ID=${{ fromJson(secrets.AZURE_CLIENT_SECRET).clientId }}" >> $GITHUB_ENV
          echo "ARM_CLIENT_SECRET=${{ fromJson(secrets.AZURE_CLIENT_SECRET).clientSecret }}" >> $GITHUB_ENV
          echo "ARM_SUBSCRIPTION_ID=${{ fromJson(secrets.AZURE_CLIENT_SECRET).subscriptionId }}" >> $GITHUB_ENV
          echo "ARM_TENANT_ID=${{ fromJson(secrets.AZURE_CLIENT_SECRET).tenantId }}" >> $GITHUB_ENV

      - name: Verify Terraform Backend
        run: |
          cd ${{ env.WORKING_DIR_DEV }}
          echo "Using backend configuration from main.tf"
          grep -A 7 'backend "azurerm"' main.tf || echo "Backend configuration embedded in main.tf"

      - name: Prepare terraform.tfvars with secrets
        run: |
          cd ${{ env.WORKING_DIR_DEV }}
          
          # Replace secret placeholders with actual values or defaults
          PROJECT_NAME="${{ secrets.PROJECT_NAME }}"
          if [ -z "$PROJECT_NAME" ]; then
            PROJECT_NAME="mlops-dev"
          fi
          
          LOCATION="${{ secrets.AZURE_LOCATION }}"
          if [ -z "$LOCATION" ]; then
            LOCATION="eastus"
          fi
          
          NOTIFICATION_EMAIL="${{ secrets.NOTIFICATION_EMAIL }}"
          if [ -z "$NOTIFICATION_EMAIL" ]; then
            NOTIFICATION_EMAIL="devops@example.com"
          fi
          
          sed -i "s/VAR_PROJECT_NAME/$PROJECT_NAME/g" terraform.tfvars
          sed -i "s/VAR_AZURE_LOCATION/$LOCATION/g" terraform.tfvars
          sed -i "s/VAR_NOTIFICATION_EMAIL/$NOTIFICATION_EMAIL/g" terraform.tfvars
          
          echo "âœ… Using environments/dev/terraform.tfvars (modular infrastructure)"
          echo "ðŸ“¦ Modules: networking, storage, ml-workspace, aks, rbac, cost-management"

      - name: Terraform Init
        run: |
          cd ${{ env.WORKING_DIR_DEV }}
          terraform init

      - name: Force Unlock State (if locked)
        run: |
          cd ${{ env.WORKING_DIR_DEV }}
          echo "ðŸ”“ Checking for state lock..."
          
          # List any existing locks
          if ! terraform plan -lock=false -input=false -detailed-exitcode &>/dev/null; then
            echo "âš ï¸ Attempting to force-unlock state..."
            
            # Try to unlock - use a generic approach that works for any lock ID
            # First, try to get the lock ID from the error message
            LOCK_ID=$(terraform plan -lock-timeout=1s 2>&1 | grep -oP 'ID:\s+\K[a-f0-9-]+' | head -1)
            
            if [ -n "$LOCK_ID" ]; then
              echo "Found lock ID: $LOCK_ID"
              terraform force-unlock -force "$LOCK_ID" || echo "Failed to unlock, will retry with -lock=false"
            else
              echo "Could not extract lock ID, proceeding with plan..."
            fi
          else
            echo "âœ… State is not locked"
          fi
        continue-on-error: true

      - name: Import Existing Resources
        run: |
          cd ./infrastructure
          chmod +x import-existing-resources.sh
          ./import-existing-resources.sh "${{ secrets.PROJECT_NAME }}" "dev" "${{ fromJson(secrets.AZURE_CLIENT_SECRET).subscriptionId }}"
        continue-on-error: true

      - name: Terraform Plan
        id: plan
        run: |
          cd ${{ env.WORKING_DIR_DEV }}
          set -o pipefail
          echo "Running terraform plan (dev)..."
          terraform plan -out=tfplan-dev -no-color | tee tfplan-dev.txt
          if [ ${PIPESTATUS[0]} -ne 0 ]; then
            echo "Terraform plan (dev) failed. Raw output saved to tfplan-dev.txt" >&2
            exit 1
          fi
          terraform show -json tfplan-dev > tfplan-dev.json

      - name: Summarize Dev Plan
        run: |
          cd ${{ env.WORKING_DIR_DEV }}
          echo "### Terraform Plan (Dev) Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          sed -n '1,200p' tfplan-dev.txt >> $GITHUB_STEP_SUMMARY || echo "(No plain-text plan captured)" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "_Truncated to first 200 lines. Full plan is in artifact tfplan-dev._" >> $GITHUB_STEP_SUMMARY
        # Remove continue-on-error to ensure failed plans stop the workflow

      - name: Comment PR with Plan
        if: github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork == false
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const fs = require('fs');
            const plan = '${{ steps.plan.outputs.stdout }}';
            
            const output = `#### Terraform Plan - Development ðŸ“
            
            \`\`\`
            ${plan.substring(0, 60000)}
            \`\`\`
            
            *Pushed by: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });

      - name: Upload Dev Plan
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-dev
          path: |
            ${{ env.WORKING_DIR_DEV }}/tfplan-dev
            ${{ env.WORKING_DIR_DEV }}/tfplan-dev.txt
            ${{ env.WORKING_DIR_DEV }}/tfplan-dev.json

  terraform-apply-dev:
    name: Deploy - Development
    needs: terraform-plan-dev
    runs-on: ubuntu-latest
    if: needs.terraform-plan-dev.result == 'success' && github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'dev' && github.event.inputs.destroy != 'true'
    environment:
      name: dev
      url: https://portal.azure.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CLIENT_SECRET }}

      - name: Validate required secrets
        run: |
          set -e
          MISSING=0
          if [ -z "${{ secrets.PROJECT_NAME }}" ]; then
            echo "Error: PROJECT_NAME secret is not set. Please add it in Settings > Secrets and variables > Actions." >&2
            MISSING=1
          fi
          if [ -z "${{ secrets.AZURE_CLIENT_SECRET }}" ]; then
            echo "Error: AZURE_CLIENT_SECRET secret is not set." >&2
            MISSING=1
          fi
          if [ $MISSING -ne 0 ]; then
            exit 1
          fi

      - name: Setup Terraform Environment Variables
        run: |
          echo "ARM_CLIENT_ID=${{ fromJson(secrets.AZURE_CLIENT_SECRET).clientId }}" >> $GITHUB_ENV
          echo "ARM_CLIENT_SECRET=${{ fromJson(secrets.AZURE_CLIENT_SECRET).clientSecret }}" >> $GITHUB_ENV
          echo "ARM_SUBSCRIPTION_ID=${{ fromJson(secrets.AZURE_CLIENT_SECRET).subscriptionId }}" >> $GITHUB_ENV
          echo "ARM_TENANT_ID=${{ fromJson(secrets.AZURE_CLIENT_SECRET).tenantId }}" >> $GITHUB_ENV

      - name: Download Dev Plan
        uses: actions/download-artifact@v4
        with:
          name: tfplan-dev
          path: ${{ env.WORKING_DIR_DEV }}

      - name: Verify Terraform Backend
        run: |
          cd ${{ env.WORKING_DIR_DEV }}
          echo "Using backend configuration from main.tf"
          grep -A 7 'backend "azurerm"' main.tf || echo "Backend configuration embedded in main.tf"

      - name: Terraform Init
        run: |
          cd ${{ env.WORKING_DIR_DEV }}
          terraform init

      - name: Force Unlock State (if locked)
        run: |
          cd ${{ env.WORKING_DIR_DEV }}
          echo "ðŸ”“ Checking for state lock before apply..."
          
          # Try to detect and unlock if needed
          LOCK_ID=$(terraform plan -lock-timeout=1s 2>&1 | grep -oP 'ID:\s+\K[a-f0-9-]+' | head -1)
          
          if [ -n "$LOCK_ID" ]; then
            echo "âš ï¸ Found lock ID: $LOCK_ID, force-unlocking..."
            terraform force-unlock -force "$LOCK_ID" || echo "Could not unlock, apply may fail"
          else
            echo "âœ… No lock detected"
          fi
        continue-on-error: true

      - name: Terraform Apply
        run: |
          cd ${{ env.WORKING_DIR_DEV }}
          terraform apply -auto-approve tfplan-dev

      - name: Terraform Output
        id: output
        run: |
          cd ${{ env.WORKING_DIR_DEV }}
          terraform output -json > outputs-dev.json
          cat outputs-dev.json

      - name: Upload Outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs-dev
          path: ${{ env.WORKING_DIR_DEV }}/outputs-dev.json

      - name: Configure Azure ML Workspace
        run: |
          # Install Azure ML CLI extension
          az extension add -n ml --upgrade -y
          
          # Get workspace details from Terraform outputs
          cd ${{ env.WORKING_DIR_DEV }}
          WORKSPACE_NAME=$(jq -r '.ml_workspace_name.value' outputs-dev.json)
          RESOURCE_GROUP=$(jq -r '.resource_group_name.value' outputs-dev.json)
          SUBSCRIPTION_ID=$(jq -r '.deployment_summary.value.subscription_id' outputs-dev.json 2>/dev/null || az account show --query id -o tsv)
          
          echo "ML Workspace: $WORKSPACE_NAME"
          echo "Resource Group: $RESOURCE_GROUP"
          echo "Subscription: $SUBSCRIPTION_ID"
          
          # Set as GitHub output for other workflows
          echo "ml_workspace_name=$WORKSPACE_NAME" >> $GITHUB_OUTPUT
          echo "resource_group_name=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "subscription_id=$SUBSCRIPTION_ID" >> $GITHUB_OUTPUT

      - name: Create Deployment Summary
        run: |
          cd ${{ env.WORKING_DIR_DEV }}
          
          echo "## ðŸš€ Infrastructure Deployment - Development" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployed Resources" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Name |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|------|" >> $GITHUB_STEP_SUMMARY
          echo "| Resource Group | $(jq -r '.resource_group_name.value' outputs-dev.json) |" >> $GITHUB_STEP_SUMMARY
          echo "| ML Workspace | $(jq -r '.ml_workspace_name.value' outputs-dev.json) |" >> $GITHUB_STEP_SUMMARY
          echo "| AKS Cluster | $(jq -r '.aks_cluster_name.value' outputs-dev.json) |" >> $GITHUB_STEP_SUMMARY
          echo "| Storage Account | $(jq -r '.storage_account_name.value' outputs-dev.json) |" >> $GITHUB_STEP_SUMMARY
          echo "| Container Registry | $(jq -r '.container_registry_name.value' outputs-dev.json) |" >> $GITHUB_STEP_SUMMARY
          echo "| Key Vault | $(jq -r '.key_vault_name.value' outputs-dev.json) |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Navigate to [Azure ML Studio](https://ml.azure.com)" >> $GITHUB_STEP_SUMMARY
          echo "2. Run training job: \`az ml job create --file src/job.yml\`" >> $GITHUB_STEP_SUMMARY
          echo "3. Monitor in Azure Portal: [Link](https://portal.azure.com/#@/resource$(jq -r '.ml_workspace_id.value' outputs-dev.json))" >> $GITHUB_STEP_SUMMARY

  terraform-plan-prod:
    name: Plan - Production
    needs: terraform-validate
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod')
    environment: 
      name: prod-plan
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CLIENT_SECRET }}

      - name: Setup Terraform Environment Variables
        run: |
          echo "ARM_CLIENT_ID=${{ fromJson(secrets.AZURE_CLIENT_SECRET).clientId }}" >> $GITHUB_ENV
          echo "ARM_CLIENT_SECRET=${{ fromJson(secrets.AZURE_CLIENT_SECRET).clientSecret }}" >> $GITHUB_ENV
          echo "ARM_SUBSCRIPTION_ID=${{ fromJson(secrets.AZURE_CLIENT_SECRET).subscriptionId }}" >> $GITHUB_ENV
          echo "ARM_TENANT_ID=${{ fromJson(secrets.AZURE_CLIENT_SECRET).tenantId }}" >> $GITHUB_ENV

      - name: Verify Terraform Backend
        run: |
          cd ${{ env.WORKING_DIR_PROD }}
          echo "Using backend configuration from main.tf"
          grep -A 7 'backend "azurerm"' main.tf || echo "Backend configuration embedded in main.tf"

      - name: Prepare terraform.tfvars with secrets
        run: |
          cd ${{ env.WORKING_DIR_PROD }}
          
          # Replace secret placeholders with actual values or defaults
          PROJECT_NAME="${{ secrets.PROJECT_NAME }}"
          if [ -z "$PROJECT_NAME" ]; then
            PROJECT_NAME="mlops-prod"
          fi
          
          LOCATION="${{ secrets.AZURE_LOCATION }}"
          if [ -z "$LOCATION" ]; then
            LOCATION="eastus"
          fi
          
          NOTIFICATION_EMAIL="${{ secrets.NOTIFICATION_EMAIL }}"
          if [ -z "$NOTIFICATION_EMAIL" ]; then
            NOTIFICATION_EMAIL="devops@example.com"
          fi
          
          sed -i "s/VAR_PROJECT_NAME/$PROJECT_NAME/g" terraform.tfvars
          sed -i "s/VAR_AZURE_LOCATION/$LOCATION/g" terraform.tfvars
          sed -i "s/VAR_NOTIFICATION_EMAIL/$NOTIFICATION_EMAIL/g" terraform.tfvars
          
          echo "âœ… Using environments/prod/terraform.tfvars with secrets injected"
          cat terraform.tfvars

      - name: Terraform Init
        run: |
          cd ${{ env.WORKING_DIR_PROD }}
          terraform init

      - name: Force Unlock State (if locked)
        run: |
          cd ${{ env.WORKING_DIR_PROD }}
          echo "ðŸ”“ Checking for state lock..."
          
          LOCK_ID=$(terraform plan -lock-timeout=1s 2>&1 | grep -oP 'ID:\s+\K[a-f0-9-]+' | head -1)
          
          if [ -n "$LOCK_ID" ]; then
            echo "âš ï¸ Found lock ID: $LOCK_ID, force-unlocking..."
            terraform force-unlock -force "$LOCK_ID" || echo "Failed to unlock"
          else
            echo "âœ… No lock detected"
          fi
        continue-on-error: true

      - name: Import Existing Resources
        run: |
          cd ./infrastructure
          chmod +x import-existing-resources.sh
          ./import-existing-resources.sh "${{ secrets.PROJECT_NAME }}" "prod" "${{ fromJson(secrets.AZURE_CLIENT_SECRET).subscriptionId }}"
        continue-on-error: true

      - name: Terraform Plan
        id: plan
        # env:
        #   SLACK_NOTIFY: ${{ secrets.SLACK_WEBHOOK_URL != '' }}
        #   SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          cd ${{ env.WORKING_DIR_PROD }}
          set -o pipefail
          echo "Running terraform plan (prod)..."
          terraform plan -out=tfplan-prod -no-color | tee tfplan-prod.txt
          if [ ${PIPESTATUS[0]} -ne 0 ]; then
            echo "Terraform plan (prod) failed. Raw output saved to tfplan-prod.txt" >&2
            exit 1
          fi
          terraform show -json tfplan-prod > tfplan-prod.json

      - name: Summarize Prod Plan
        run: |
          cd ${{ env.WORKING_DIR_PROD }}
          echo "### Terraform Plan (Prod) Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          sed -n '1,200p' tfplan-prod.txt >> $GITHUB_STEP_SUMMARY || echo "(No plain-text plan captured)" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "_Truncated to first 200 lines. Full plan is in artifact tfplan-prod._" >> $GITHUB_STEP_SUMMARY
        # Remove continue-on-error to ensure failed plans stop the workflow

      - name: Upload Prod Plan
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-prod
          path: |
            ${{ env.WORKING_DIR_PROD }}/tfplan-prod
            ${{ env.WORKING_DIR_PROD }}/tfplan-prod.txt
            ${{ env.WORKING_DIR_PROD }}/tfplan-prod.json

  terraform-apply-prod:
    name: Deploy - Production
    needs: terraform-plan-prod
    runs-on: ubuntu-latest
    if: needs.terraform-plan-prod.result == 'success' && ((github.ref == 'refs/heads/main' && github.event_name == 'push') || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod' && github.event.inputs.destroy != 'true'))
    environment:
      name: production
      url: https://portal.azure.com
    # env:
    #   SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CLIENT_SECRET }}

      - name: Setup Terraform Environment Variables
        run: |
          echo "ARM_CLIENT_ID=${{ fromJson(secrets.AZURE_CLIENT_SECRET).clientId }}" >> $GITHUB_ENV
          echo "ARM_CLIENT_SECRET=${{ fromJson(secrets.AZURE_CLIENT_SECRET).clientSecret }}" >> $GITHUB_ENV
          echo "ARM_SUBSCRIPTION_ID=${{ fromJson(secrets.AZURE_CLIENT_SECRET).subscriptionId }}" >> $GITHUB_ENV
          echo "ARM_TENANT_ID=${{ fromJson(secrets.AZURE_CLIENT_SECRET).tenantId }}" >> $GITHUB_ENV

      - name: Download Prod Plan
        uses: actions/download-artifact@v4
        with:
          name: tfplan-prod
          path: ${{ env.WORKING_DIR_PROD }}

      - name: Verify Terraform Backend
        run: |
          cd ${{ env.WORKING_DIR_PROD }}
          echo "Using backend configuration from main.tf"
          grep -A 7 'backend "azurerm"' main.tf || echo "Backend configuration embedded in main.tf"

      - name: Terraform Init
        run: |
          cd ${{ env.WORKING_DIR_PROD }}
          terraform init

      - name: Force Unlock State (if locked)
        run: |
          cd ${{ env.WORKING_DIR_PROD }}
          echo "ðŸ”“ Checking for state lock before apply..."
          
          LOCK_ID=$(terraform plan -lock-timeout=1s 2>&1 | grep -oP 'ID:\s+\K[a-f0-9-]+' | head -1)
          
          if [ -n "$LOCK_ID" ]; then
            echo "âš ï¸ Found lock ID: $LOCK_ID, force-unlocking..."
            terraform force-unlock -force "$LOCK_ID" || echo "Could not unlock"
          else
            echo "âœ… No lock detected"
          fi
        continue-on-error: true

      - name: Terraform Apply
        run: |
          cd ${{ env.WORKING_DIR_PROD }}
          terraform apply -auto-approve tfplan-prod

      - name: Terraform Output
        id: output
        run: |
          cd ${{ env.WORKING_DIR_PROD }}
          terraform output -json > outputs-prod.json
          cat outputs-prod.json

      - name: Upload Outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs-prod
          path: ${{ env.WORKING_DIR_PROD }}/outputs-prod.json

      # Slack notification - Uncomment when SLACK_WEBHOOK_URL secret is configured
      # - name: Send Slack Notification
      #   if: ${{ env.SLACK_WEBHOOK_URL != '' }}
      #   uses: slackapi/slack-github-action@v1
      #   with:
      #     payload: |
      #       {
      #         "text": "ðŸš€ Production Infrastructure Deployed",
      #         "blocks": [
      #           {
      #             "type": "header",
      #             "text": {
      #               "type": "plain_text",
      #               "text": "ðŸš€ Production Infrastructure Deployed"
      #             }
      #           },
      #           {
      #             "type": "section",
      #             "fields": [
      #               {
      #                 "type": "mrkdwn",
      #                 "text": "*Environment:*\nProduction"
      #               },
      #               {
      #                 "type": "mrkdwn",
      #                 "text": "*Deployed by:*\n${{ github.actor }}"
      #               }
      #             ]
      #           }
      #         ]
      #       }
      #   env:
      #     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      #     SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

      - name: Create Deployment Summary
        run: |
          cd ${{ env.WORKING_DIR_PROD }}
          
          echo "## ðŸš€ Infrastructure Deployment - Production" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployed Resources" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Name |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|------|" >> $GITHUB_STEP_SUMMARY
          echo "| Resource Group | $(jq -r '.resource_group_name.value' outputs-prod.json) |" >> $GITHUB_STEP_SUMMARY
          echo "| ML Workspace | $(jq -r '.ml_workspace_name.value' outputs-prod.json) |" >> $GITHUB_STEP_SUMMARY
          echo "| AKS Cluster | $(jq -r '.aks_cluster_name.value' outputs-prod.json) |" >> $GITHUB_STEP_SUMMARY
          echo "| Storage Account | $(jq -r '.storage_account_name.value' outputs-prod.json) |" >> $GITHUB_STEP_SUMMARY
          echo "| Container Registry | $(jq -r '.container_registry_name.value' outputs-prod.json) |" >> $GITHUB_STEP_SUMMARY
          echo "| Key Vault | $(jq -r '.key_vault_name.value' outputs-prod.json) |" >> $GITHUB_STEP_SUMMARY

  # Export infrastructure outputs as GitHub Variables for ML pipelines
  export-dev-outputs:
    name: Export DEV Outputs to GitHub Variables
    needs: dev-apply
    if: github.event_name != 'pull_request' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/deployment-pipeline')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Terraform Init
        working-directory: ${{ env.WORKING_DIR_DEV }}
        run: terraform init

      - name: Extract DEV Outputs
        id: dev_outputs
        working-directory: ${{ env.WORKING_DIR_DEV }}
        run: |
          echo "resource_group=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
          echo "ml_workspace=$(terraform output -raw ml_workspace_name)" >> $GITHUB_OUTPUT
          echo "aks_cluster=$(terraform output -raw aks_cluster_name)" >> $GITHUB_OUTPUT
          echo "acr_name=$(terraform output -raw container_registry_name)" >> $GITHUB_OUTPUT
          echo "acr_login_server=$(terraform output -raw container_registry_login_server)" >> $GITHUB_OUTPUT
          echo "storage_account=$(terraform output -raw storage_account_name)" >> $GITHUB_OUTPUT
          echo "key_vault=$(terraform output -raw key_vault_name)" >> $GITHUB_OUTPUT
          echo "app_insights=$(terraform output -raw application_insights_name)" >> $GITHUB_OUTPUT

      - name: Set GitHub Variables for DEV
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh variable set DEV_RESOURCE_GROUP --body "${{ steps.dev_outputs.outputs.resource_group }}"
          gh variable set DEV_ML_WORKSPACE --body "${{ steps.dev_outputs.outputs.ml_workspace }}"
          gh variable set DEV_AKS_CLUSTER --body "${{ steps.dev_outputs.outputs.aks_cluster }}"
          gh variable set DEV_ACR_NAME --body "${{ steps.dev_outputs.outputs.acr_name }}"
          gh variable set DEV_ACR_LOGIN_SERVER --body "${{ steps.dev_outputs.outputs.acr_login_server }}"
          gh variable set DEV_STORAGE_ACCOUNT --body "${{ steps.dev_outputs.outputs.storage_account }}"
          gh variable set DEV_KEY_VAULT --body "${{ steps.dev_outputs.outputs.key_vault }}"
          gh variable set DEV_APP_INSIGHTS --body "${{ steps.dev_outputs.outputs.app_insights }}"
          gh variable set AZURE_SUBSCRIPTION_ID --body "b2b8a5e6-9a34-494b-ba62-fe9be95bd398"
          gh variable set AZURE_REGION --body "eastus"

      - name: Output Summary
        run: |
          echo "## âœ… DEV Infrastructure Variables Updated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The following GitHub variables have been set for ML pipelines:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- DEV_RESOURCE_GROUP: ${{ steps.dev_outputs.outputs.resource_group }}" >> $GITHUB_STEP_SUMMARY
          echo "- DEV_ML_WORKSPACE: ${{ steps.dev_outputs.outputs.ml_workspace }}" >> $GITHUB_STEP_SUMMARY
          echo "- DEV_AKS_CLUSTER: ${{ steps.dev_outputs.outputs.aks_cluster }}" >> $GITHUB_STEP_SUMMARY
          echo "- DEV_ACR_NAME: ${{ steps.dev_outputs.outputs.acr_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ¨ ML pipelines can now reference these via \`vars.DEV_RESOURCE_GROUP\`, etc." >> $GITHUB_STEP_SUMMARY

  export-prod-outputs:
    name: Export PROD Outputs to GitHub Variables
    needs: prod-apply
    if: github.event_name != 'pull_request' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/deployment-pipeline')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Terraform Init
        working-directory: ${{ env.WORKING_DIR_PROD }}
        run: terraform init

      - name: Extract PROD Outputs
        id: prod_outputs
        working-directory: ${{ env.WORKING_DIR_PROD }}
        run: |
          echo "resource_group=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
          echo "ml_workspace=$(terraform output -raw ml_workspace_name)" >> $GITHUB_OUTPUT
          echo "aks_cluster=$(terraform output -raw aks_cluster_name)" >> $GITHUB_OUTPUT
          echo "acr_name=$(terraform output -raw container_registry_name)" >> $GITHUB_OUTPUT
          echo "acr_login_server=$(terraform output -raw container_registry_login_server)" >> $GITHUB_OUTPUT
          echo "storage_account=$(terraform output -raw storage_account_name)" >> $GITHUB_OUTPUT
          echo "key_vault=$(terraform output -raw key_vault_name)" >> $GITHUB_OUTPUT
          echo "app_insights=$(terraform output -raw application_insights_name)" >> $GITHUB_OUTPUT

      - name: Set GitHub Variables for PROD
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh variable set PROD_RESOURCE_GROUP --body "${{ steps.prod_outputs.outputs.resource_group }}"
          gh variable set PROD_ML_WORKSPACE --body "${{ steps.prod_outputs.outputs.ml_workspace }}"
          gh variable set PROD_AKS_CLUSTER --body "${{ steps.prod_outputs.outputs.aks_cluster }}"
          gh variable set PROD_ACR_NAME --body "${{ steps.prod_outputs.outputs.acr_name }}"
          gh variable set PROD_ACR_LOGIN_SERVER --body "${{ steps.prod_outputs.outputs.acr_login_server }}"
          gh variable set PROD_STORAGE_ACCOUNT --body "${{ steps.prod_outputs.outputs.storage_account }}"
          gh variable set PROD_KEY_VAULT --body "${{ steps.prod_outputs.outputs.key_vault }}"
          gh variable set PROD_APP_INSIGHTS --body "${{ steps.prod_outputs.outputs.app_insights }}"

      - name: Output Summary
        run: |
          echo "## âœ… PROD Infrastructure Variables Updated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The following GitHub variables have been set for ML pipelines:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- PROD_RESOURCE_GROUP: ${{ steps.prod_outputs.outputs.resource_group }}" >> $GITHUB_STEP_SUMMARY
          echo "- PROD_ML_WORKSPACE: ${{ steps.prod_outputs.outputs.ml_workspace }}" >> $GITHUB_STEP_SUMMARY
          echo "- PROD_AKS_CLUSTER: ${{ steps.prod_outputs.outputs.aks_cluster }}" >> $GITHUB_STEP_SUMMARY
          echo "- PROD_ACR_NAME: ${{ steps.prod_outputs.outputs.acr_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ¨ ML pipelines can now reference these via \`vars.PROD_RESOURCE_GROUP\`, etc." >> $GITHUB_STEP_SUMMARY
